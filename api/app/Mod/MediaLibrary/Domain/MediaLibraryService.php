<?php

namespace App\Mod\MediaLibrary\Domain;

use App\Domain\BaseService;
use Symfony\Component\HttpFoundation\Request;
use App\Mod\MediaLibrary\Domain\Models\MediaLibrary;

/**
 * @property MediaLibrary $model
 */
class MediaLibraryService extends BaseService
{

    public function __construct(MediaLibrary $model)
    {
        parent::__construct($model);
    }

    public function findList(Request $request, ?int $limit = null, array $with = []): array
    {
        if (!$limit) {
            $limit = config('media_library.list.limit');
        }
        return parent::findList($request, $limit, $with); // TODO: Change the autogenerated stub
    }

    public function appendCriteria(?array $criteria = [], $query): void
    {
        parent::appendCriteria($criteria, $query); // TODO: Change the autogenerated stub
    }

    public function validateRequest(Request $request, mixed $post = null): void
    {
        $request->validate(
            [
                "file_name" => ['required'],
            ],
            [
                'title.file_name' => 'タイトルは必須項目です。',
            ]
        );
    }

    /**
     * 追加
     */
    public function store(Request $request): array
    {
        return $this->chunkUpload($request);
    }

    /**
     * メディア変更
     */
    public function updateMedia(Request $request, ?int $id = null): array
    {
        $beforeModel = $this->model->find($id);
        // チャンクアップロード
        $result = $this->chunkUpload($request, $id);

        if ($result['status'] === 'completed') {
            // ファイル削除（ストレージからの相対パスを絶対パスに変換
            $this->deleteFileDirectory($beforeModel->file_path);
        }

        return $result;
    }

    /**
     * 更新時
     */
    public function beforeSave(Request $request, MediaLibrary $model, array &$inputs): void
    {
        unset($inputs['file']);

        // ファイル名が変更された場合
        if (isset($inputs['file_name']) && $inputs['file_name'] !== $model->file_name) {
            $this->renameMedia($model, $inputs['file_name']);
        }
    }

    /**
     * 削除後実行
     */
    public function afterDelete(Request $request, MediaLibrary $model): void
    {
        // ファイルディレクトリを削除
        $this->deleteFileDirectory($model->file_path);
    }

    /**
     * ファイルディレクトリを削除
     */
    private function deleteFileDirectory(string $relativePath): void
    {
        // ファイル削除（ストレージからの相対パスを絶対パスに変換）
        $fullPath = storage_path('app/public/' . $relativePath);
        if (file_exists($fullPath)) {
            unlink($fullPath);
        }

        // ストレージからの相対パスを絶対パスに変換
        $fullPath = storage_path('app/public/' . $relativePath);

        // ファイルのディレクトリを取得
        $fileDirectory = dirname($fullPath);

        // ディレクトリが存在するかチェック
        if (is_dir($fileDirectory)) {
            // ディレクトリ内のファイルを取得
            $files = glob($fileDirectory . '/*');

            // ディレクトリが空の場合のみ削除
            if (empty($files)) {
                rmdir($fileDirectory);
            }
        }
    }

    /**
     * チャンクアップロード
     */
    protected function chunkUpload(Request $request, ?int $id = null): array
    {
        $fileName = $request->input('fileName'); // 元のファイル名
        $chunkIndex = (int)$request->input('chunkIndex'); // 今のチャンク番号
        $totalChunks = (int)$request->input('totalChunks'); // 全部で何チャンクか
        $chunk = $request->file('file'); // 今回のチャンクデータ

        // 一時保存ディレクトリ
        $tmpDir = storage_path('app/chunks/' . $fileName);
        if (!is_dir($tmpDir)) {
            mkdir($tmpDir, 0777, true);
        }

        // チャンクを一時保存 (例: sample.jpg.part0)
        $chunk->move($tmpDir, $fileName . '.part' . $chunkIndex);

        // 最後のチャンクならファイルを結合
        if ($chunkIndex + 1 === $totalChunks) {
            $date = new \DateTime();
            $finalPath = storage_path('app/public/uploads/' . $date->format('Y/m/d/') . uniqid() . "/" . $fileName);
            if (!is_dir(dirname($finalPath))) {
                mkdir(dirname($finalPath), 0777, true);
            }

            $out = fopen($finalPath, 'ab');
            for ($i = 0; $i < $totalChunks; $i++) {
                $chunkFile = $tmpDir . '/' . $fileName . '.part' . $i;
                $in = fopen($chunkFile, 'rb');
                stream_copy_to_stream($in, $out);
                fclose($in);
                unlink($chunkFile); // チャンク削除
            }
            fclose($out);

            // 一時ディレクトリ削除
            rmdir($tmpDir);

            // メディアライブラリ保存
            $fileSize = filesize($finalPath);
            $mimeType = mime_content_type($finalPath);

            // ストレージからの相対パスを生成
            $relativePath = 'uploads/' . $date->format('Y/m/d/') . basename(dirname($finalPath)) . "/" . $fileName;
            $fileUrl = asset('storage/' . $relativePath);

            // 画像サイズの取得
            $imageSize = null;
            if (str_starts_with($mimeType, 'image/')) {
                $imageInfo = getimagesize($finalPath);
                if ($imageInfo !== false) {
                    $imageSize = json_encode([
                        'width' => $imageInfo[0],
                        'height' => $imageInfo[1]
                    ]);
                }
            }

            $mediaData = [
                'file_name' => $fileName,
                'file_path' => $relativePath,  // ストレージからの相対パス
                'file_url' => $fileUrl,
                'mime_type' => $mimeType,
                'file_size' => $fileSize,
                'image_size' => $imageSize
            ];

            if (!$id) {
                $mediaLibrary = $this->model->create($mediaData);
            } else {
                $mediaLibrary = $this->model->find($id);
                $mediaLibrary->update($mediaData);
            }

            return [
                'status' => 'completed',
                'path' => $relativePath,  // ストレージからの相対パス
                'url' => $fileUrl,
                'media_id' => $mediaLibrary->id
            ];
        }

        return ['status' => 'chunk_received'];
    }

    /**
     * メディアファイルをリネーム
     */
    protected function renameMedia(MediaLibrary $model, string $newFileName)
    {
        // 現在のファイルパス
        $currentPath = storage_path('app/public/' . $model->file_path);

        // 新しいファイルパス（同じディレクトリ、新しいファイル名）
        $newPath = dirname($currentPath) . '/' . $newFileName;

        // ファイルが存在する場合のみリネーム
        if (file_exists($currentPath)) {
            // ファイルをリネーム
            if (rename($currentPath, $newPath)) {
                // 新しい相対パスを生成
                $newRelativePath = dirname($model->file_path) . '/' . $newFileName;

                // 新しいURLを生成
                $newUrl = asset('storage/' . $newRelativePath);

                // モデルの属性を更新
                $model->file_name = $newFileName;
                $model->file_path = $newRelativePath;
                $model->file_url = $newUrl;
            }
        }
    }
}
